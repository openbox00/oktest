/*
 * Description:   ARMv5 specific TCB handling functions
 */
#ifndef __ARM__V5__TCB_H__
#define __ARM__V5__TCB_H__

#include <arch/fass.h>
#include <arch/fass_inline.h>


#if defined (__GNUC__)

#define asm_initial_switch_to(new_sp, new_pc)                               \
    __asm__ __volatile__ (                                                  \
        "    mov     sp,     %0              \n" /* load new stack ptr */   \
        "    mov     pc,     %1              \n" /* load new PC */          \
        :: "r" (new_sp), "r" (new_pc)                                       \
        : "memory")

#elif defined (__RVCT_GNU__)

#define asm_initial_switch_to(new_sp, new_pc)   \
    jump_and_set_sp((word_t)new_pc, new_sp)
#elif defined (_lint)
#define asm_initial_switch_to(new_sp, new_pc) jump_and_set_sp((word_t)new_pc, new_sp)
#else
#error unknown compiler
#endif

/**********************************************************************
 *
 *                      thread switch routines
 *
 **********************************************************************/
/**
 * switch to initial thread
 * @param tcb TCB of initial thread
 *
 * Initializes context of initial thread and switches to it.  The
 * context (e.g., instruction pointer) has been generated by inserting
 * a notify procedure context on the stack.  We simply restore this
 * context.
 */

INLINE void NORETURN initial_switch_to (tcb_t * tcb)
{
    tcb_t ** stack_top;

    word_t new_pt = (word_t) page_table_to_phys(get_cpd());

    get_arm_fass()->activate_domain(tcb->get_space());

    arm_cache::cache_flush();

    USER_UTCB_REF = tcb->get_utcb_location();

    /* drain write buffer */
    write_cp15_register(C15_cache_con, c10, 0x4, 0x0);
    /* install new PT */
    write_cp15_register(C15_ttbase, C15_CRm_default, C15_OP2_default, new_pt);
    /* flush TLB */
    write_cp15_register(C15_tlb, c7, C15_OP2_default, 0x0);

    /* keep stack aligned for RVCT */
    stack_top = ((tcb_t **)(&__stack + 1))-2;

    /* switch */
    asm_initial_switch_to((addr_t)stack_top, tcb->cont);

    while(true) {}
}

/**
 * read the user-level instruction pointer
 * @return      the user-level stack pointer
 */
INLINE addr_t tcb_t::get_user_ip()
{
    arm_irq_context_t * context = &arch.context;

    return (addr_t)(context->pc & ~1UL);
}

/**
 * set the user-level instruction pointer
 * @param ip    new user-level instruction pointer
 */
INLINE void tcb_t::set_user_ip(addr_t ip)
{
    word_t new_pc = (word_t)ip;
    arm_irq_context_t *context = &arch.context;

#ifdef CONFIG_ARM_THUMB_SUPPORT
    /* CPU has thumb support, fix cpsr if needed */
    if (new_pc & 1)
        context->cpsr |= CPSR_THUMB_BIT;
    else
        context->cpsr &= ~CPSR_THUMB_BIT;
#endif

    /* Keep exception frame type bit */
    if (context->pc & 1)
        new_pc |= 1;
    else
        new_pc &= ~1UL;

    context->pc = new_pc;
}


#endif /*__ARM__V5__TCB_H__*/
