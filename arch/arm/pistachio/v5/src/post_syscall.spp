/*
 * ARM Exception Vectors and IPC /Exception Fastpaths
 */

#include <l4.h>
#include <tcb_layout.h>
#include <ktcb_layout.h>
#include <context_layout.h>
#include <asmsyms.h>
#include <arch/globals.h>
#include <arch/thread.h>
#include <arch/syscalls.h>
#include <kernel/arch/asm.h>
#include <l4/arch/vregs.h>
#include <arch/fass.h>

#if defined(__RVCT_GNU__)
        PRESERVE8
        AREA    |.post_syscall.data|, ALIGN=12, CODE, READWRITE
#endif
        IMPORT  start_post_syscall_callback
        IMPORT  __stack
        IMPORT  vector_kernel_access
        IMPORT  vector_stack_top
/*
 * Call an arbitrary C function prior to returning back to userspace
 * from a syscall.
 *
 * At this point, we expect:
 *   - CURRENT_TCB is correct
 *   - r0 - r14 have precious userspace values that need to be saved
 *     (for instance, the return paramters of a syscall that just
 *     finished).
 *   - The user SPSR needs to be saved.
 *   - User PC is stored in kernel LR
 */
        ALIGN   32
        BEGIN_PROC(arm_perform_callback_saveregs)
        /* Load current TCB's context frame. */
        mov     sp,     #ARM_GLOBAL_BASE
        ldr     sp,     [sp, #OFS_GLOBAL_CURRENT_TCB]
        add     sp,     sp, #OFS_TCB_ARCH_CONTEXT

        /* Save all user registers */
        stmib   sp,     {r0-r14}^   /* Save user registers r0 - r7 */
        nop

        /* Save user PC / CPSR */
        str     lr,     [sp, #PT_PC]
        mrs     lr,    spsr
        nop
        str     lr,    [sp, #PT_CPSR] /* Save tmp1(r11) to CPSR */

        /* Setup FASS for kernel. Macro clobbers register r12 (ip) */
        ldr     ip,     =vector_kernel_access
        ldr     ip,     [ip]
        mcr     p15,    0,  ip, c3, c0

        /* Call 'start_post_syscall_callback' */
        ldr     r1,     =start_post_syscall_callback
        ldr     sp,     =vector_stack_top
        ldr     sp,     [sp]
        adr     lr,     arm_finish_callback_restoreregs
        jump    r1
        END_PROC(arm_perform_callback_saveregs)

        BEGIN_PROC(arm_finish_callback_restoreregs)
        /* Return back to userspace after doing some post-syscall work. */
        SET_USER_DACR
        RESTORE_ALL
        movs    pc,     lr
        END_PROC(arm_finish_callback_restoreregs)

/*
 * Call an arbitrary C function prior to returning back to userspace
 * from an exception.
 *
 * At this point, we expect:
 *   - CURRENT_TCB is correct
 *   - All user registers have been saved in the TCB.
 */
        ALIGN   32
        BEGIN_PROC(arm_perform_callback_from_interrupt)
        /* Setup FASS for kernel. Macro clobbers register r12 (ip) */
        ldr     ip,     =vector_kernel_access
        ldr     ip,     [ip]
        mcr     p15,    0,  ip, c3, c0

        /* Call 'start_post_syscall_callback' */
        ldr     r1,     =start_post_syscall_callback
        ldr     sp,     =vector_stack_top
        ldr     sp,     [sp]
        adr     lr,     arm_finish_callback_from_interrupt
        jump    r1

        END_PROC(arm_perform_callback_from_interrupt)

        BEGIN_PROC(arm_finish_callback_from_interrupt)
        /* Return back to userspace after doing some post-exception work. */
        SET_USER_DACR
        RESTORE_ALL
        subs    pc,     lr,     #1
        END_PROC(arm_finish_callback_from_interrupt)
        LTORG
        END
